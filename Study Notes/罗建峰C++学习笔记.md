罗建峰C++学习笔记

# C++概论

## C++程序的生命周期

一个C++程序从诞生到消亡会经历下面四个阶段

### 编码

​	定义变量 写语句 实现数据机构、函数和类

### 预处理

​	预处理是C/C++程序独有的阶段，在这个阶段，发挥作用的是预处理器，它的输入是编码阶段产生的源码文件，输出是经过预处理的源码文件，预处理的目的是文字替换，会用到诸如#include，#define，#if，实现预处理编程。

### 编译和链接

​	编译就是将源代码“翻译”成计算机可以识别的二进制格式（机器码），它们以目标文件的形式存在；链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。

### 运行

​	编译和链接后会生成可执行文件，有了可执行文件后，C++程序就可以运行

## 编程规范

​	编程格言：任何人都能写出机器看得懂的代码，只有优秀的程序员才能写出人能看懂的代码

这就意味着我们需要一些明确的、经过实践验证的规则来指导，只需要遵守以及合理运用这些规则，我们就能写出良好的代码。

### 代码格式

适当增加空格和空行

### 标识符命名

为变量、函数、类起一个易懂的例子

类变量 m_小驼峰

类函数 小驼峰

等

### 注释

写出了有好名字的变量、函数和类还不够，还需要加上注释

注释必须正确、清晰、有效、



## 	一个好的类

高效、安全、灵活 --等评价指标

### 设计思想

抽象和封装：把问题中的实体抽象出来，封装为程序的类和对象

### 实现原则

1.要使用继承，那么需要控制继承的层次，如果继承的深度超过三层，则需要考虑使用组合关系来替代继承关系，或者改用模板和泛型。

2.在设计类接口的时候，也要让类尽量简单，只负责单一的功能。

![image-20210817201257750](.\Picture\image-20210817201257750.png)

### 常用技巧

#### 委托构造：

1. 当类有多个不同类型的构造函数，为了初始化成员变量，肯定会有大量重复的代码，为了避免重复，常见的做法是：把公共的部分提取出来，放到init（）函数里，在构造函数调用。
	这种方法可行，但是效率和可读性比较差，毕竟init（）不是真正的构造函数
	
2. 在C++11里，可以使用委托构造的新特性，一个构造函数直接调用另一个构造函数，把构造工作委托出去，既简单又高效

   ![image-20210817223026328](.\Picture\image-20210817223026328.png)

#### 成员变量初始化

​	如果类有很多成员变量，那么再写构造函数的时候容易遗漏成员，造成未初始化的隐患。

​	在C++11里，可以在类声明的同时赋值，实现初始化，不但清晰，也消除了隐患。

![image-20210817224926678](.\Picture\image-20210817224926678.png)

#### 类型别名 	Type Alias

​	C++扩展了关键字using的用法，增加了typedef的能力，可以定义类型别名，它的格式与typedef正好相反，别名在左边，原名在右边，是标准的赋值类型。

![](.\Picture\image-20210817225235954.png)
	

​	在写类的时候，经常会用到外部类型，比如标准库的string、vector等，这些名字通常很长，书写起来非常不方便，这个使用在类中使用using给它们起别名，不仅简化了名字，同时还增强了可读性。
![image-20210817225451218](.\Picture\image-20210817225451218.png)

# C++语言特性

## 	自动类型推导

### 	什么是自动类型推导

计算机自动算出操作目标的类型。

###  为什么要自动类型推导

C++是一种静态强类型[^1]的语言，任何变量都要有一个确定的类型，否则就不能用。这在变量类型简单的时候还好说，但是在泛型编程[^2]的时候，就会有很多麻烦。

[^1]: 编译期间做检查数据类型的语言，即写程序时要声明所有变量的数据类型，是固定的。 使用数据之前，必须先声明数据类型（int ,float,double等）。 相当于使用之前，首先要为它们分配好内存空间。
[^2]:泛型程序设计是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。

![image-20210818000045904](.\Picture\image-20210818000045904.png)

编译器其实知道变量的类型，但是你不知道或者不容易推导出来。有了自动类型推导，问题就迎刃而解。

### 	C++中如何使用自动类型推导		

​	关键字auto

​	auto的自动推导智能用在初始化，纯变量的声明不能使用auto，因为没有表达式可以让auto去推导，目前C++不允许类成员变量初始化使用auto，auto总是推导出值类型，绝不会是引用。

~~~C++
vector<int> v = {2,3,4,7,11};
for(auto & i:v){//使用自动类型推导 使用引用方式访问元素，避免拷贝代价
    std::cout<<i<<", ";
}

//auto可以附加const * &　得到新的类型
auto x = 10L ;//auto 推导为long x是long
auto & x1 = x;//auto 推导为long x1是long &
auto * x2 = &x;//auto 推导为long x2是long *
~~~

关键字decltype

​	关键字auto的使用必须从表达式推导，在没有表达式的时候可以使用decltype，从而可以直接声明变量。
~~~C++
int x=0; //整型变量

decltype(x) x1;//推导为int x1是int
decltype(x)& x2=x;//推导为int  x2是int& 引用必须赋值
decltype(x)* x3;//推导为int x3是int *
decltype(x2) x4=x2;//推导为int& x4是int& 引用必须赋值
~~~

decltype不仅能够推导出值类型，还能够推导出引用类型。在定义类的时候，auto不被允许声明变量，decltype可以搭配别名（typedef）应用到成员变量、函数。

~~~C++
using set_type = std::set<int>;//集合类型别名
class A{
    public :
    private :
    	set_type m_set;//使用别名定义成员变量
    	using iter_type = decltype(m_set.begin());//使用decltype计算表达式类型 定义别名
    	iter_type m_pos;//类型别名定义成员变量
}
~~~

## 	常量与变量
~~~C++
vector<int> v = {2,3,4,7,11};
for(const auto & i:v){//使用自动类型推导 使用引用方式访问元素，避免拷贝代价
    std::cout<<i<<", ";
}
~~~
auto推导出的类型可以使用const、volatile修饰（cv修饰符）
### 	const的基本用法
~~~C++
//const可以用来定义常量 代替宏定义(预处理阶段)
const int MAX_LEN = 1024 ;//MAX_LEN是运行时的变量 不允许修改

int x=100;
const int& rx=x;//const常量引用
const int* px=&x;//const常量指针 一直指向x
~~~
### 	const相关的用法
~~~C++
//const可以用于定义成员函数
class A{
	private: 
		const int MAX_SIZE = 256;//const成员变量
		int m_value;
	public:
		//该成员函数是一个只读操作
		int get_value() const{
			return m_value;
		}
}
//标准库vector的empty() size() 等查看基本属性的操作都是const的
~~~

### 	const与volatile
正确使用cv修饰符可以使得代码更加安全、运行更快。
~~~C++
//const可以用来定义常量 代替宏定义(预处理阶段)

const int MAX_LEN = 1024 ;//MAX_LEN是运行时的变量 不允许修改

/*
变量可以使用指针获取地址 再强制写入

const在预处理阶段并不存在 编译器看到const定义后，会采取优化手段，比如在编译阶段将const常量出现的地方替换成原始值
而volatile会禁止编译器做优化
*/
const volatile int MAX_LEN=1024 ;

auto ptr = (int*)(&MAX_LEN);
*ptr=2048;
std::cout<<MAX_LEN<<endl;//输出2048
~~~


### 	~~关键字mutable~~

​	在多线程加锁的时候会用上

![image-20210818112415195](.\Picture\image-20210818112415195.png)









智能指针

什么是智能指针

​	首先介绍naked pointer(裸指针，指针)，源自C语言的概念，本质上是一个内存地址索引，代表一片内存区域，可以直接读写内存，因为完全映射了计算机硬件，所有操作效率高，是C/C++高效的根源，也是引起麻烦的根源。访问无效数据、指针越界、内存分配后没有及时释放导致的运行错误、内存泄漏、资源丢失等一系列严重的问题。

​	Java、Go等编程语言内置了一个垃圾回收机制，会检测不再使用的内存，自动释放资源。

​	C++的回收机制：构造/析构函数和RAII惯用法（resource acquisition is initialization）

1. 为了避免裸指针可能出现的问题，可以使用代理模式，将裸指针包装起来，在构造函数初始化，析构函数释放，但是需要包装所有的裸指针，比较麻烦。
2. 使用智能指针，智能指针完全实践了RAII，包装了裸指针，重载了*和->操作符，用起来和裸指针一样。

智能指针有两种，分别是unique_ptr和shared_ptr

认识unique_ptr

​	声明的时候，必须使用模板参数指定类型

~~~C++
unique_ptr<int>ptr1(new int(10));// int 智能指针
assert(*ptr1==10);//可以使用*取内容
assert(ptr1!=nullptr);//可以判断是否为空指针
// 需要注意 unique_ptr 实际上是一个对象 会自动管理初始化时的指针 离开作用域时 会析构释放内存
// 指针所有权是唯一的 不允许共享 通过赋值转移后 丢失指针的所有权
}
~~~

认识shared_ptr

​	使用方法同unique_ptr，和unique_ptr最大的不同在于：所有权是可以被安全共享的，也就说支持拷贝赋值

~~~C++
auto ptr1=make_shared<int>(42);//工厂函数创建智能指针
auto ptr2 = ptr1;//支持拷贝赋值
// 支持安全共享的密码在于 内部使用了引用计数 发生拷贝赋值则引用计数就增加 发生析构时引用计数就减少
~~~

相对unique_ptr来说，引用计数的存储和管理都是成本。共享指针可能出现循环引用的问题（作为类成员，链表节点），要杜绝循环引用则需要用到weak_ptr

![image-20210829185622837](.\Picture\image-20210829185622837.png)



# 异常

c++为了处理错误而提出的一种解决方案

异常的三个特点：

1. 异常的处理流程是完全独立的，分离了业务逻辑和错误逻辑

2. 异常是绝对不能被忽略的，必须被处理

3. 异常可以用在错误码无法使用的场合

# 函数式编程

lambda函数

1. [=]	表示按值捕获所有外部变量，不能修改
2. [&]	表示按引用捕获所有的外部变量，可以修改
C++14 泛型化lambda
~~~C++
auto f=[](const auto &x){//参数使用auto声明 泛型化
return x+x;

cout<<f(3);//参数类型是int
cout<<f(0.618);//参数类型是double

}
~~~



C++标准库

string

1. 字面量后缀 
2. 原始字符串  不会对字符串里的内容做任何转义
3. 字符串转换函数
4. 字符串视图类  大字符串拷贝修改代价高，C++17提供一个string_view

容器（顺序容器、有序容器、无序容器）



# 并发与多线程

并发[^3]

[^3]: 一个时间段内有多个操作同时进行	

并发有很多种实现方式，多线程是其中一种常用的手段。

线程 thread ：一个能够独立运行的函数

多线程开发的原则：仅调用一次，线程局部存储，原子变量和线程对象

仅调用一次 call_once ：保证只初始化数据一次

线程局部存储 thread_local：线程独占所有权 关键词thread_local

原子变量 atomic：禁用拷贝构造函数

线程 thread：

序列化/反序列化，网络通信，脚本语言混合编程，性能分析

序列化：把内存里活的对象转换成静止的字节序列，便于存储和网络传输；反序列化：从静止的字节序列重新构建出内存可用的对象。三种简单高效的数据交换格式，JSON，MessagePack和ProtoBuffer

JSON：方便易用，性能上不具有太大的优势，





网络编程

​	C++中几个好用的网络通信库，libcurl，cpr，ZMQ

​	libcurl和cpr处理的都是HTTP协议，协议自身有一些限制，比如必须一来一回，必须点对点直连，在超大数据量通信的时候就不大合适，且libcurl和cpr只能充当HTTP客户端。cpr是libcurl的C++封装，接口简单易用。

​	ZMQ(zero message queue)零延迟的消息队列，一个高级的网络通信库，支持多种通信模式，可以把消息对俩功能直接嵌入应用程序，搭建出高效、灵活、免管理的分布式系统。



搭建混合系统

​	充分使用Python和Lua脚本语言

性能分析

​	pstack，strace，perf--不用修改源码，简单易用，效果不是很理想

​	Google Performance Tools，要想获得可读的信息，还需要要一个工具脚本pprof--侵入式性能分析工具

设计模式与设计原则

​	系统性地描述了一些软件开发中的常见问题、应用场景和对应的解决方案，给出了**专家级别的设计思路和指导原则**。	

​	设计原则--SOLID

1. SRP 单一职责（Single responsibility principle）
2. OCP 开闭（Open closed principle）
3. LSP 里氏替换 （Liskov substitution principle）
4. ISP 接口依赖 （Interface segregation principle）
5. DIP 依赖反转/依赖倒置 （Dependency inversion principle）

单一职责原理：不要做多余的事，功能明确单一，反例是C++标准库里的字符串类string，集成了字符串和字符容器的双重身份，接口复杂。

开闭原理：对扩展开放，对修改关闭，即做好封装，隐藏内部的具体实现细节，然后开放足够的接口，外部的客户就可以只通过接口去扩展功能。

里氏替换原则：子类必须能够完全替代父类，即子类不能改变或违反父类定义的行为。比如，鸟类的例子

![image-20210905155737955](.\Picture\image-20210905155737955.png)

接口隔离原理：对外的接口尽量简化，归并给外界调用的接口

依赖反转原则：上层要避免依赖下层的实现细节，下层要反过来依赖上层的抽象定义。

《设计模式》介绍了23个模式，根据设计目的可以分为三大类：如何创建对象（创建型模式），如何组合对象，如何处理对象之间的动态通信和职责分配。

创建型模式：隐藏了类的实例化过程和细节，让对象的创建独立于系统的其他部分。

<img src=".\Picture\image-20210905163812082.png" alt="image-20210905163812082" style="zoom:67%;" />

​	单例（单件）：只能有一个实例

​	抽象工厂是一个类，工厂方法是一个函数，使用工厂来创建对象，隔离了客户代码和创建对象，实现了解耦。

结构性模式：关注的是对象的静态联系，以灵活、可拆卸、可装配的方式组合出新的对象。

<img src=".\Picture\image-20210905171829598.png" alt="image-20210905171829598" style="zoom:67%;" />

常用的是：适配器、外观和代理

​	适配器模式：接口转换，不需要修改源码

​	外观：封装了一组对象，提供一个高层次的易用接口，降低系统的复杂度。

​	代理：不允许外部直接与内部对象通信

行为模式：描述了对象之间动态的消息传递，也就是对象的行为、工作方式。

<img src=".\Picture\image-20210905172119686.png" alt="image-20210905172119686" style="zoom:67%;" />

职责链、命令和策略
.\Picture


​	C++的异常处理机制就是职责链+命令的一个实际应用

​	策略：封装了不同的算法，可以在运行的时候灵活互相替换，不会改变类的外部表现和内部状态。

<img src=".\Picture\image-20210905172432700.png" alt="image-20210905172432700" style="zoom:67%;" />

visio和starUML绘图工具

？？？显示转移构造 

《设计模式：可复用面向对象软件的基础》---面向对象

《C++标准程序库》									---泛型编程 C++98/第一版

《C++语言的设计与演化》                         ---历史读本

《C++Primer》										   ---科教全书

有数，倒数日--app推荐

